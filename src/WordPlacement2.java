import java.io.IOException;import java.util.*;import java.io.BufferedReader;public class WordPlacement2{    public static final int Unsolved = -1;    int letterValueNotInMap = -2;    private char[][] puzzleBoard;    private int startX = -1, startY = -1;    private List<String> dictionary;    Map<Character, Integer> letterValues;    private int totalScore;    private int numRows;    private int numCols;    private Map<String, PlacementInfo> placedWords = new HashMap<>();    private final String reservedChars = ".TD*23";    private class PlacementInfo {        int startRow;        int startCol;        boolean isHorizontal;        PlacementInfo(int startRow, int startCol, boolean isHorizontal) {            this.startRow = startRow;            this.startCol = startCol;            this.isHorizontal = isHorizontal;        }    }    public boolean loadBoard(BufferedReader puzzleStream) {        try {            if(puzzleStream == null){                return false;            }            String line;            List<String> boardRows = new ArrayList<>();            // Read lines from the puzzleStream and store them in a list            while ((line = puzzleStream.readLine()) != null) {                boardRows.add(line);            }            // Determine the dimensions of the puzzle board            numRows = boardRows.size();            numCols = boardRows.get(0).length();            // Initialize the puzzle board with the correct dimensions            puzzleBoard = new char[numRows][numCols];            boolean starFound = false;            // Fill in the puzzle board based on the loaded data            for (int i = 0; i < numRows; i++) {                String row = boardRows.get(i);                for (int j = 0; j < numCols; j++) {                    char cell = row.charAt(j);                    if(reservedChars.indexOf(Character.toUpperCase(cell)) == -1){                        return false;                    }                    // check if there are more than 1 starting points                    if(cell == '*'){                        if(starFound) {                            startX = -1;                            startY = -1;                            return false;                        } else {                            startX = i;                            startY = j;                            starFound = true;                        }                    }                    // Add char to board                    puzzleBoard[i][j] = Character.toUpperCase(cell);                }            }            return true; // Successfully loaded the board        } catch (IOException e) {            e.printStackTrace();            return false; // Error occurred while reading the board        }    }    public boolean dictionary(BufferedReader wordStream) {        try {            if(wordStream == null){                return false;            }            String line;            dictionary = new ArrayList<>();            // Read lines from the wordStream and add them to the dictionary            while ((line = wordStream.readLine()) != null) {                dictionary.add(line.trim().toLowerCase()); // Trim to remove leading/trailing spaces            }            return true; // Successfully loaded the dictionary        } catch (IOException e) {            e.printStackTrace();            return false; // Error occurred while reading the dictionary        }    }    public boolean letterValue(BufferedReader valueStream) {        try {            if(valueStream == null){                return false;            }            String line;            letterValues = new HashMap<>();            // Read lines from the valueStream and parse letter values            while ((line = valueStream.readLine()) != null) {                String[] parts = line.split("\t"); // Assuming values are tab-separated                if (parts.length == 2) {                    char letter = parts[0].charAt(0);                    if(Character.toLowerCase(letter) - 'a' < 0 || Character.toLowerCase(letter) - 'a' > 26){                        return false;                    }                    int value = Integer.parseInt(parts[1]);                    if(value > 9 || value < 0){                        return false;                    }                    // Store letter value in the map                    letterValues.put(Character.toLowerCase(letter), value);                } else{                    return false;                }            }            return true; // Successfully loaded the letter values        } catch (IOException | NumberFormatException e) {            e.printStackTrace();            return false; // Error occurred while reading the letter values        }    }    public int placeWords(List<String> words) {        if(words == null || words.size() == 0){            return -1;        }        if(!preprocessWordsList(words)){            return -1;        };        int firstWordIndex = 0;        // Find the position of "*" on the board//        int startX = -1, startY = -1;//        for (int i = 0; i < numRows; i++) {//            for (int j = 0; j < numCols; j++) {//                if (puzzleBoard[i][j] == '*') {//                    startX = i;//                    startY = j;//                    break;//                }//            }//            if (startX != -1) {//                break;//            }//        }        if (startX == -1 || startY == -1) {            return -1; // Starting position not found        }        // Place the first word on the board        if (!dictionary.contains(words.get(firstWordIndex))) {            return -1; // The first word is not in the dictionary        }        int firstWordScoreHorizontal = calculateScore(startX,startY,words.get(firstWordIndex), true, 0);        int firstWordScoreVertical = calculateScore(startX,startY,words.get(firstWordIndex), false, 0);        if(firstWordScoreHorizontal >= firstWordScoreVertical){            placeWord(startX, startY, words.get(firstWordIndex),true);            totalScore += firstWordScoreHorizontal;        } else{            placeWord(startX, startY, words.get(firstWordIndex),false);            totalScore += firstWordScoreVertical;        }        firstWordIndex++;        for (int wordIndex = firstWordIndex; wordIndex < words.size(); wordIndex++) {            String word = words.get(wordIndex);            if (!dictionary.contains(word)) {                return -1; // Word is not in the dictionary            }            int maxScore = Integer.MIN_VALUE;            int bestRow = -1;            int bestCol = -1;            boolean bestIsHorizontal = true;            // Check for common characters and try to place the new word by crossing            for (String placedWord : placedWords.keySet()) {                // Find crossing                for (int i = 0; i < placedWord.length(); i++) {                    char placedChar = placedWord.charAt(i);                    int matchingIndex = word.indexOf(placedChar);                    while(matchingIndex >= 0) {                        int wordLength = word.length();                        boolean isPlacedWordHorizontal = placedWords.get(placedWord).isHorizontal;                        int commonRow = isPlacedWordHorizontal ? placedWords.get(placedWord).startRow : placedWords.get(placedWord).startRow + i;                        int commonCol = isPlacedWordHorizontal ? placedWords.get(placedWord).startCol + i: placedWords.get(placedWord).startCol;                        String prefix = word.substring(0, matchingIndex);                        String suffix = word.substring(matchingIndex + 1);                        int prefixLength = prefix.length();                        int suffixLength = suffix.length();                        // check if horizontally fits                        // checks if it goes out of board horizontally                        if (commonCol - prefixLength >= 0 && commonCol + suffixLength < numCols) {                            if (canCrossWord(commonRow, commonCol, prefix, true, true, word) && canCrossWord(commonRow, commonCol, suffix, true, false, word)) {//                                int score = calculateScore(commonRow, commonCol, word, true, prefixLength);                                int score = calculateScore(commonRow, commonCol - prefixLength, word, true, prefixLength);                                if(score == letterValueNotInMap){                                    return -1;                                }                                if (score > maxScore) {                                    maxScore = score;                                    bestRow = commonRow;                                    bestCol = commonCol - prefixLength;                                    bestIsHorizontal = true;                                }                            }                        }                        // check if vertically fits                        if (commonRow - prefixLength >= 0 && commonRow + suffixLength < numRows) {                            if (canCrossWord(commonRow, commonCol, prefix, false, true, word) && canCrossWord(commonRow, commonCol, suffix, false, false, word)) {//                                int score = calculateScore(commonRow, commonCol, word, false, prefixLength);                                int score = calculateScore(commonRow - prefixLength, commonCol, word, false, prefixLength);                                if(score == letterValueNotInMap){                                    return -1;                                }                                if (score > maxScore) {                                    maxScore = score;                                    bestRow = commonRow - prefixLength;                                    bestCol = commonCol;                                    bestIsHorizontal = false;                                }                            }                        }                        matchingIndex = word.indexOf(placedChar, matchingIndex + 1);                    }                }            }            // Check for ending's extensions            for (String placedWord : placedWords.keySet()) {                boolean isPlacedWordHorizontal = placedWords.get(placedWord).isHorizontal;                int placedWordStartRow = placedWords.get(placedWord).startRow;                int placedWordStartCol = placedWords.get(placedWord).startCol;                int extendedRow = -1;                int extendedCol = -1;                List <Integer> bestScoreXY = null;                if(isPlacedWordHorizontal){                    bestScoreXY = checkHorizontalExtension(placedWordStartRow, placedWordStartCol, word);                    if(bestScoreXY!= null && bestScoreXY.get(0) > maxScore){                        maxScore = bestScoreXY.get(0);                        bestRow = bestScoreXY.get(1);                        bestCol = bestScoreXY.get(2);                        bestIsHorizontal = false;                    }                    bestScoreXY = checkVerticalExtension(placedWordStartRow, placedWordStartCol, word);                    if(bestScoreXY!= null && bestScoreXY.get(0) > maxScore){                        maxScore = bestScoreXY.get(0);                        bestRow = bestScoreXY.get(1);                        bestCol = bestScoreXY.get(2);                        bestIsHorizontal = false;                    }                }                if(!isPlacedWordHorizontal){                    bestScoreXY = checkHorizontalPlacementVerticallyPlacedWord(placedWordStartRow, placedWordStartCol, word);                    if(bestScoreXY!= null && bestScoreXY.get(0) > maxScore){                        maxScore = bestScoreXY.get(0);                        bestRow = bestScoreXY.get(1);                        bestCol = bestScoreXY.get(2);                        bestIsHorizontal = false;                    }                    bestScoreXY = checkVerticalPlacementVerticallyPlacedWord(placedWordStartRow, placedWordStartCol, word);                    if(bestScoreXY!= null && bestScoreXY.get(0) > maxScore){                        maxScore = bestScoreXY.get(0);                        bestRow = bestScoreXY.get(1);                        bestCol = bestScoreXY.get(2);                        bestIsHorizontal = false;                    }                }            }            if (maxScore == Integer.MIN_VALUE) {                return -1; // Unable to place the word on the board            }            // Place the word based on the best starting position            placeWord(bestRow, bestCol, word, bestIsHorizontal);            totalScore += maxScore;        }        return totalScore;    }    private boolean preprocessWordsList(List<String> strings) {        ListIterator<String> iterator = strings.listIterator();        while (iterator.hasNext())        {            String nextWord = iterator.next();            if(nextWord == null || nextWord.trim().length() == 0){                return false;            }            iterator.set(nextWord.trim().toLowerCase());        }        return true;    }    private boolean canCrossWord(int row, int col, String word, boolean isHorizontal, boolean isPrefix, String currentWord) {        int wordLength = word.length();        if (isHorizontal) {            for (int i = 0; i < wordLength; i++) {                char boardCell = isPrefix ? puzzleBoard[row][col - wordLength + i] : puzzleBoard[row][col + i + 1];                char wordCell = word.charAt(i);                if (reservedChars.indexOf(boardCell) == -1 && boardCell != wordCell) {                    return false;                }            }            if(isPrefix) {                // Check if the placed word is extended further horizontally by other words                return isWordExtendingHorizontally(row, col, wordLength, currentWord);            }        }        else {            for (int i = 0; i < wordLength; i++) {                char boardCell = isPrefix ? puzzleBoard[row - wordLength + i][col] : puzzleBoard[row + i + 1][col];                char wordCell = word.charAt(i);                if (reservedChars.indexOf(boardCell) == -1 && boardCell != wordCell) {                    return false;                }            }            if(isPrefix) {                // Check if the placed word is extended further horizontally by other words                return isWordExtendingVertically(row, col, wordLength, currentWord);            }        }        return true; // The word doesn't connect to existing words    }    private boolean isWordExtendingHorizontally(int row, int col, int wordLength, String currentWord){        // Check if the placed word is extended further horizontally by other words        int tempColMin = col - wordLength - 1;        int tempColMax = col - wordLength + currentWord.length();        // Check for left word extension        while (tempColMin >= 0) {            if (reservedChars.indexOf(puzzleBoard[row][tempColMin]) == -1) {                --tempColMin;            } else {                ++tempColMin;                break;            }        }        if(tempColMin < 0){            tempColMin = 0;        }        // Check for right word extension        while (tempColMax < numCols) {            if (reservedChars.indexOf(puzzleBoard[row][tempColMax]) == -1) {                ++tempColMax;            } else {                --tempColMax;                break;            }        }        if(tempColMax>=numCols){            tempColMax = numCols - 1;        }        // If word is extended, check if it is present in dictionary        if (tempColMin < col - wordLength || tempColMax > col - wordLength + currentWord.length() - 1) {            StringBuilder isWord = new StringBuilder("");            for (int i = tempColMin, j = 0; i <= tempColMax; ++i) {                if(i >= col){                    isWord.append(currentWord.charAt(j));                    ++j;                }                else {                    isWord.append(puzzleBoard[row][i]);                }            }            if (!dictionary.contains(isWord.toString())) {                return false;            }        }        return true;    }    private boolean isWordExtendingVertically(int row, int col, int wordLength, String currentWord) {        // Check if the placed word is extended further horizontally by other words        int tempRowMin = row - wordLength - 1;        int tempRowMax = row - wordLength + currentWord.length();        // Check for left word extension        while (tempRowMin >= 0) {            boolean isBoardLetterReserved = reservedChars.indexOf(puzzleBoard[tempRowMin][col]) != -1;            if (!isBoardLetterReserved) {                --tempRowMin;            } else {                ++tempRowMin;                break;            }        }        if(tempRowMin < 0){            tempRowMin = 0;        }        // Check for right word extension        while (tempRowMax < numRows) {            if (reservedChars.indexOf(puzzleBoard[tempRowMax][col]) == -1) {                ++tempRowMax;            } else {                --tempRowMax;                break;            }        }        if(tempRowMax >= numRows){            tempRowMax = numRows - 1;        }        // If word is extended, check if it is present in dictionary        if (tempRowMin < row - wordLength || tempRowMax > row - wordLength + currentWord.length() -1) {            StringBuilder isWord = new StringBuilder("");            for (int i = tempRowMin; i <= tempRowMax; ++i) {                isWord.append(puzzleBoard[i][col]);            }            if (!dictionary.contains(isWord.toString())) {                return false;            }        }        return true;    }    private List checkHorizontalExtension(int row, int col, String word){        int wordLength = word.length();        // Check if the placed word is extended further horizontally by other words        int tempColMin = col - 1;        int tempColMax = col + wordLength;        int maxScore = Integer.MIN_VALUE;        int bestRow = -1;        int bestCol = -1;        // Check for left word extension        while (tempColMin >= 0) {            if (reservedChars.indexOf(puzzleBoard[row][tempColMin]) == -1) {                --tempColMin;            } else {                ++tempColMin;                break;            }        }        if(tempColMin < 0){            tempColMin = 0;        }        // Check for right word extension        while (tempColMax < numCols) {            if (reservedChars.indexOf(puzzleBoard[row][tempColMax]) == -1) {                ++tempColMax;            } else {                --tempColMax;                break;            }        }        if(tempColMax >= numCols){            tempColMax = numCols - 1;        }        if(tempColMin>0) {            int wordScore = 0;            // Calculate word score            for(int j = 0; j < wordLength; j++){                char charWord = word.charAt(j);                if(!letterValues.containsKey(charWord)){                    return null;                }                wordScore += letterValues.get(charWord);            }            // Get the new word formed            StringBuilder isWord = new StringBuilder("");            StringBuilder newWord = new StringBuilder("");            for (int i = tempColMin, j = 0; i <= tempColMax; ++i) {                isWord.append(puzzleBoard[row][i]);            }            int freeRowsAbove = 0;            int freeRowsBelow = 0;            // Get the rows free above            for(int i = 1 ; i < wordLength; i++){                if(reservedChars.indexOf(puzzleBoard[row - i][tempColMin - 1]) != -1){                    ++freeRowsAbove;                } else {                    break;                }            }            // Get the rows free below            for(int i = 1 ; i < wordLength; i++){                if(reservedChars.indexOf(puzzleBoard[row + i][tempColMin - 1]) != -1){                    ++freeRowsBelow;                } else {                    break;                }            }            if(freeRowsAbove + freeRowsBelow - 1 >= wordLength){                for (int i = 0; i < wordLength; i++) {                    if(freeRowsAbove >= i && freeRowsBelow >= wordLength - i - 1){                        int newWordScore = 0;                        char wordChar = word.charAt(i);                        newWord.setLength(0);                        newWord.append(wordChar);                        newWord.append(isWord);                        if(dictionary.contains(newWord)){                            for(int j = 0; j < newWord.length(); j++){                                char charNewWord = newWord.charAt(j);                                if(!letterValues.containsKey(charNewWord)){                                    return null;                                }                                newWordScore += letterValues.get(charNewWord);                            }                            newWordScore += wordScore;                            if(newWordScore > maxScore){                                maxScore = newWordScore;                                bestRow = row - i;                                bestCol = tempColMin - 1;                            }                        }                    }                }            }        }        if(tempColMax < numCols - 1) {            int wordScore = 0;            // Calculate word score            for(int j = 0; j < wordLength; j++){                char charWord = word.charAt(j);                if(!letterValues.containsKey(charWord)){                    return null;                }                wordScore += letterValues.get(charWord);            }            // Get the new word formed            StringBuilder isWord = new StringBuilder("");            StringBuilder newWord = new StringBuilder("");            for (int i = tempColMin, j = 0; i <= tempColMax; ++i) {                isWord.append(puzzleBoard[row][i]);            }            int freeRowsAbove = 0;            int freeRowsBelow = 0;            // Get the rows free above            for(int i = 1 ; i < wordLength; i++){                if(reservedChars.indexOf(puzzleBoard[row - i][tempColMax + 1]) != -1){                    ++freeRowsAbove;                } else {                    break;                }            }            // Get the rows free below            for(int i = 1 ; i < wordLength; i++){                if(reservedChars.indexOf(puzzleBoard[row + i][tempColMax + 1]) != -1){                    ++freeRowsBelow;                } else {                    break;                }            }            if(freeRowsAbove + freeRowsBelow - 1 >= wordLength){                for (int i = 0; i < wordLength; i++) {                    if(freeRowsAbove >= i && freeRowsBelow >= wordLength - i - 1){                        int newWordScore = 0;                        char wordChar = word.charAt(i);                        newWord.setLength(0);                        newWord.append(isWord);                        newWord.append(wordChar);                        if(dictionary.contains(newWord)){                            for(int j = 0; j < newWord.length(); j++){                                char charNewWord = newWord.charAt(j);                                if(!letterValues.containsKey(charNewWord)){                                    return null;                                }                                newWordScore += letterValues.get(charNewWord);                            }                            newWordScore += wordScore;                            if(newWordScore > maxScore){                                maxScore = newWordScore;                                bestRow = row - i;                                bestCol = tempColMax + 1;                            }                        }                    }                }            }        }        if (maxScore == Integer.MIN_VALUE || bestRow == -1 || bestCol == -1){            return null;        }        List<Integer> res = new ArrayList<>();        res.add(maxScore);        res.add(bestRow);        res.add(bestCol);        return res;    }    private List checkHorizontalPlacementVerticallyPlacedWord(int row, int col, String word){        int wordLength = word.length();        int wordScore = 0;        // Check if the placed word is extended further horizontally by other words        int tempRowMin = row - 1;        int tempRowMax = row + wordLength;        int maxScore = Integer.MIN_VALUE;        int bestRow = -1;        int bestCol = -1;        // Check for left word extension        while (tempRowMin >= 0) {            if (reservedChars.indexOf(puzzleBoard[row][tempRowMin]) == -1) {                --tempRowMin;            } else {                ++tempRowMin;                break;            }        }        if(tempRowMin < 0){            tempRowMin = 0;        }        // Check for right word extension        while (tempRowMax < numCols) {            if (reservedChars.indexOf(puzzleBoard[row][tempRowMax]) == -1) {                ++tempRowMax;            } else {                --tempRowMax;                break;            }        }        if(tempRowMax >= numCols){            tempRowMax = numCols - 1;        }        // Calculate word score        for (int j = 0; j < wordLength; j++) {            char charWord = word.charAt(j);            if (!letterValues.containsKey(charWord)) {                return null;            }            wordScore += letterValues.get(charWord);        }        StringBuilder newWord = new StringBuilder(word);        // Check word formation horizontally left of vertically placed word        if(row - wordLength >=0){            // Traverse the whole horizontally placed word            for (int i = tempRowMin; i<= tempRowMax; i++){                newWord.append(puzzleBoard[i][col]);                if(dictionary.contains(newWord.toString())){                    // Check the rows free above                    int freeColsLeft = 0;                    int newWordScore = wordScore + letterValues.get(puzzleBoard[i][col]);                    int tempScore = wordScore + newWordScore;                    for (int j = 1; j <= wordLength; j++) {                        if (reservedChars.indexOf(puzzleBoard[i][col-j]) != -1) {                            ++freeColsLeft;                        } else {                            break;                        }                    }                    if(freeColsLeft >= wordLength){                        if(tempScore > maxScore){                            bestRow = i;                            bestCol = col - wordLength;                            maxScore = tempScore;                        }                    }                }                newWord = new StringBuilder(word);            }        }        newWord.setLength(0);        // Check word formation horizontally right of vertically placed word        if(row + wordLength < numRows){            // Traverse the whole horizontally placed word            for (int i = tempRowMin; i<= tempRowMax; i++){                newWord.append(puzzleBoard[i][col]);                newWord.append(word);                if(dictionary.contains(newWord.toString())){                    // Check the rows free above                    int freeColsRight = 0;                    int newWordScore = wordScore + puzzleBoard[i][col];                    int tempScore = wordScore + newWordScore;                    for (int j = 1; j <= wordLength; j++) {                        if (reservedChars.indexOf(puzzleBoard[i][col + j]) != -1) {                            ++freeColsRight;                        } else {                            break;                        }                    }                    if(freeColsRight >= wordLength){                        if(tempScore > maxScore){                            bestRow = row + 1;                            bestCol = i;                            maxScore = tempScore;                        }                    }                }                newWord.setLength(0);            }        }//        if (maxScore == Integer.MIN_VALUE || bestRow == -1 || bestCol == -1){            return null;        }        List<Integer> res = new ArrayList<>();        res.add(maxScore);        res.add(bestRow);        res.add(bestCol);        return res;    }    private List<Integer> checkVerticalExtension(int row, int col, String word) {        int wordLength = word.length();        int maxScore = Integer.MIN_VALUE;        int bestRow = -1;        int bestCol = -1;        int wordScore = 0;        // Check if the placed word is extended further horizontally by other words        int tempColMin = col - 1;        int tempColMax = col + wordLength;        // Check for left word extension        while (tempColMin >= 0) {            if (reservedChars.indexOf(puzzleBoard[row][tempColMin]) == -1) {                --tempColMin;            } else {                ++tempColMin;                break;            }        }        if(tempColMin < 0){            tempColMin = 0;        }        // Check for right word extension        while (tempColMax < numCols) {            if (reservedChars.indexOf(puzzleBoard[row][tempColMax]) == -1) {                ++tempColMax;            } else {                --tempColMax;                break;            }        }        if(tempColMax >= numCols){            tempColMax = numCols - 1;        }        // Calculate word score        for (int j = 0; j < wordLength; j++) {            char charWord = word.charAt(j);            if (!letterValues.containsKey(charWord)) {                return null;            }            wordScore += letterValues.get(charWord);        }        StringBuilder newWord = new StringBuilder(word);        // Check word formation vertically above horizontally placed word        if(row - wordLength >=0){            // Traverse the whole horizontally placed word            for (int i = tempColMin; i<= tempColMax; i++){                newWord.append(puzzleBoard[row][i]);                if(dictionary.contains(newWord.toString())){                    // Check the rows free above                    int freeRowsAbove = 0;                    int newWordScore = wordScore + letterValues.get(puzzleBoard[row][i]);//                        int newWordScore = wordScore + puzzleBoard[row][i];                    int tempScore = wordScore + newWordScore;                    for (int j = 1; j <= wordLength; j++) {                        if (reservedChars.indexOf(puzzleBoard[row - j][i]) != -1) {                            ++freeRowsAbove;                        } else {                            break;                        }                    }                    if(freeRowsAbove >= wordLength){                        if(tempScore > maxScore){                            bestRow = row - wordLength;                            bestCol = i;                            maxScore = tempScore;                        }                    }                }                newWord = new StringBuilder(word);            }        }        newWord.setLength(0);        // Check word formation vertically below horizontally placed word        if(row + wordLength < numRows){            // Traverse the whole horizontally placed word            for (int i = tempColMin; i<= tempColMax; i++){                newWord.append(puzzleBoard[row][i]);                newWord.append(word);                if(dictionary.contains(newWord.toString())){                    // Check the rows free above                    int freeRowsBelow = 0;                    int newWordScore = wordScore + puzzleBoard[row][i];                    int tempScore = wordScore + newWordScore;                    for (int j = 1; j <= wordLength; j++) {                        if (reservedChars.indexOf(puzzleBoard[row + j][i]) != -1) {                            ++freeRowsBelow;                        } else {                            break;                        }                    }                    if(freeRowsBelow >= wordLength){                        if(tempScore > maxScore){                            bestRow = row + 1;                            bestCol = i;                            maxScore = tempScore;                        }                    }                }                newWord.setLength(0);            }        }        if (maxScore == Integer.MIN_VALUE || bestRow == -1 || bestCol == -1) {            return null;        }        List<Integer> res = new ArrayList<>();        res.add(maxScore);        res.add(bestRow);        res.add(bestCol);        return res;    }    private List checkVerticalPlacementVerticallyPlacedWord(int row, int col, String word){        int wordLength = word.length();        int wordScore = 0;        // Check if the placed word is extended further horizontally by other words        int tempRowMin = row - 1;        int tempRowMax = row + wordLength;        int maxScore = Integer.MIN_VALUE;        int bestRow = -1;        int bestCol = -1;        // Check for left word extension        while (tempRowMin >= 0) {            if (reservedChars.indexOf(puzzleBoard[row][tempRowMin]) == -1) {                --tempRowMin;            } else {                ++tempRowMin;                break;            }        }        if(tempRowMin < 0){            tempRowMin = 0;        }        // Check for right word extension        while (tempRowMax < numCols) {            if (reservedChars.indexOf(puzzleBoard[row][tempRowMax]) == -1) {                ++tempRowMax;            } else {                --tempRowMax;                break;            }        }        if(tempRowMax >= numCols){            tempRowMax = numCols - 1;        }        // Calculate word score        for (int j = 0; j < wordLength; j++) {            char charWord = word.charAt(j);            if (!letterValues.containsKey(charWord)) {                return null;            }            wordScore += letterValues.get(charWord);        }        if(tempRowMin>0) {            // Get the new word formed            StringBuilder isWord = new StringBuilder("");            StringBuilder newWord = new StringBuilder("");            for (int i = tempRowMin; i <= tempRowMax; ++i) {                isWord.append(puzzleBoard[i][col]);            }            int freeColsLeft = 0;            int freeColsRight = 0;            // Get the free columns on left            for(int i = 1 ; i < wordLength; i++){                if(reservedChars.indexOf(puzzleBoard[tempRowMin - 1][col - i]) != -1){                    ++freeColsLeft;                } else {                    break;                }            }            // Get the free columns on right            for(int i = 1 ; i < wordLength; i++){                if(reservedChars.indexOf(puzzleBoard[tempRowMin - 1][col + i]) != -1){                    ++freeColsRight;                } else {                    break;                }            }            if(freeColsLeft + freeColsRight - 1 >= wordLength){                for (int i = 0; i < wordLength; i++) {                    if(freeColsLeft >= i && freeColsRight >= wordLength - i - 1){                        int newWordScore = 0;                        char wordChar = word.charAt(i);                        newWord.setLength(0);                        newWord.append(wordChar);                        newWord.append(isWord);                        if(dictionary.contains(newWord)){                            for(int j = 0; j < newWord.length(); j++){                                char charNewWord = newWord.charAt(j);                                if(!letterValues.containsKey(charNewWord)){                                    return null;                                }                                newWordScore += letterValues.get(charNewWord);                            }                            newWordScore += wordScore;                            if(newWordScore > maxScore){                                maxScore = newWordScore;                                bestRow = tempRowMin - 1;                                bestCol = col - i;                            }                        }                    }                }            }        }        if(tempRowMax < numRows - 1) {            // Get the new word formed            StringBuilder isWord = new StringBuilder("");            StringBuilder newWord = new StringBuilder("");            for (int i = tempRowMin; i <= tempRowMax; ++i) {                isWord.append(puzzleBoard[i][col]);            }            int freeColsLeft = 0;            int freeColsRight = 0;            // Get the free columns on left            for(int i = 1 ; i < wordLength; i++){                if(reservedChars.indexOf(puzzleBoard[tempRowMax + 1][col - i]) != -1){                    ++freeColsLeft;                } else {                    break;                }            }            // Get the free columns on right            for(int i = 1 ; i < wordLength; i++){                if(reservedChars.indexOf(puzzleBoard[tempRowMax + 1][col + i]) != -1){                    ++freeColsRight;                } else {                    break;                }            }            if(freeColsLeft + freeColsRight - 1 >= wordLength){                for (int i = 0; i < wordLength; i++) {                    if(freeColsLeft >= i && freeColsRight >= wordLength - i - 1){                        int newWordScore = 0;                        char wordChar = word.charAt(i);                        newWord.setLength(0);                        newWord.append(isWord);                        newWord.append(wordChar);                        if(dictionary.contains(newWord)){                            for(int j = 0; j < newWord.length(); j++){                                char charNewWord = newWord.charAt(j);                                if(!letterValues.containsKey(charNewWord)){                                    return null;                                }                                newWordScore += letterValues.get(charNewWord);                            }                            newWordScore += wordScore;                            if(newWordScore > maxScore){                                maxScore = newWordScore;                                bestRow = tempRowMax + 1;                                bestCol = col - i;                            }                        }                    }                }            }        }        if (maxScore == Integer.MIN_VALUE || bestRow == -1 || bestCol == -1){            return null;        }        List<Integer> res = new ArrayList<>();        res.add(maxScore);        res.add(bestRow);        res.add(bestCol);        return res;    }    private int calculateScore(int row, int col, String word, boolean isHorizontal, int prefixLength) {        int wordLength = word.length();        int wordMultiplier = 1;        int totalScore = 0;        int totalWordMultiplier = 1;        int newWordScore = 0;        // Calculate the word score        for (int i = 0; i < wordLength; i++) {            char cell = isHorizontal ? puzzleBoard[row][col + i] : puzzleBoard[row + i][col];            if(!letterValues.containsKey(word.charAt(i))){                return letterValueNotInMap;            }            int letterValue = letterValues.get(word.charAt(i));            switch (cell) {                case '*':                    totalWordMultiplier *= 2;                    break;                case 'D':                    totalWordMultiplier *= 2;                    break;                case 'T':                    totalWordMultiplier *= 3;                    break;                case '2':                    letterValue *= 2;                    break;                case '3':                    letterValue *= 3;                    break;            }            totalScore += letterValue;        }        totalScore *= totalWordMultiplier;        // Check for newly formed words and their scores        if (isHorizontal) {            // Check if the placed word is extended further horizontally by other words            int tempColMin = col - 1;            int tempColMax = col + wordLength;            // Check for left word extension            while (tempColMin >= 0) {                if (reservedChars.indexOf(puzzleBoard[row][tempColMin]) == -1) {                    --tempColMin;                } else {                    ++tempColMin;                    break;                }            }            if(tempColMin < 0){                tempColMin = 0;            }            // Check for right word extension            while (tempColMax < numCols) {                if (reservedChars.indexOf(puzzleBoard[row][tempColMax]) == -1) {                    ++tempColMax;                } else {                    --tempColMax;                    break;                }            }            if(tempColMax>=numCols){                tempColMax = numCols - 1;            }            // If word is extended, check if it is present in dictionary            if (tempColMin < col - prefixLength || tempColMax > col + wordLength - 1) {                StringBuilder isWord = new StringBuilder("");                for (int i = tempColMin; i <= tempColMax; ++i) {                    newWordScore += reservedChars.indexOf(puzzleBoard[row][i]) == -1 ? letterValues.get(puzzleBoard[row][i]) : letterValues.get(word.charAt(i-tempColMin));                    isWord.append(puzzleBoard[row][i]);                }                if (!dictionary.contains(isWord.toString())) {                    return -1;                }            }            totalScore += newWordScore ;        } else {            // Check if the placed word is extended further horizontally by other words            int tempRowMin = row - 1;            int tempRowMax = row + wordLength;            // Check for left word extension            while (tempRowMin >= 0) {                boolean isBoardLetterReserved = reservedChars.indexOf(puzzleBoard[tempRowMin][col]) != -1;                if (!isBoardLetterReserved) {                    --tempRowMin;                } else {                    ++tempRowMin;                    break;                }            }            if(tempRowMin < 0){                tempRowMin = 0;            }            // Check for right word extension            while (tempRowMax < numRows) {                if (reservedChars.indexOf(puzzleBoard[tempRowMax][col]) == -1) {                    ++tempRowMax;                } else {                    --tempRowMax;                    break;                }            }            if(tempRowMax >= numRows){                tempRowMax = numRows - 1;            }            // If word is extended, check if it is present in dictionary            if (tempRowMin < row - wordLength || tempRowMax > row + wordLength -1) {                StringBuilder isWord = new StringBuilder("");                for (int i = tempRowMin; i <= tempRowMax; ++i) {                    newWordScore += reservedChars.indexOf(puzzleBoard[i][col]) == -1 ? letterValues.get(puzzleBoard[i][col]) : letterValues.get(word.charAt(i-tempRowMin));                    isWord.append(puzzleBoard[i][col]);                }                if (!dictionary.contains(isWord.toString())) {                    return -1;                }            }            totalScore += newWordScore ;        }        return totalScore;    }    private void placeWord(int row, int col, String word, boolean isHorizontal) {        int wordLength = word.length();        if (isHorizontal) {            for (int i = 0; i < wordLength; i++) {                puzzleBoard[row][col + i] = word.charAt(i);            }        } else {            for (int i = 0; i < wordLength; i++) {                puzzleBoard[row + i][col] = word.charAt(i);            }        }        // Update the placedWords map to keep track of the newly placed word        placedWords.put(word, new PlacementInfo(row, col, isHorizontal));    }    public void print(){        for (int i =0; i<puzzleBoard.length; i++){            for (int j =0; j<puzzleBoard[0].length; j++){                System.out.print(puzzleBoard[i][j]);            }            System.out.println("");        }    }}